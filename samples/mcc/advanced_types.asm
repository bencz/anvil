***********************************************************************
*        Generated by ANVIL for IBM S/370
***********************************************************************
         CSECT
         AMODE ANY
         RMODE ANY
*
MAIN     DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING MAIN,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
MAIN$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         LA    R2,0            Load constant
         ST    R2,88(,R13)        Store to stack slot
         XC    92(4,R13),92(R13)  Init local var to 0
         LA    R2,10            Load constant
         ST    R2,92(,R13)        Store to stack slot
         XC    96(4,R13),96(R13)  Init local var to 0
         LA    R2,20            Load constant
         ST    R2,96(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R15,92(,R13)       Load from stack slot
         L     R15,96(,R13)       Load from stack slot
*        Call setup (reentrant)
         L     R0,92(,R13)       Load value from stack slot
         ST    R0,100(,R13)       Store param 0
         L     R0,96(,R13)       Load value from stack slot
         ST    R0,104(,R13)       Store param 1
         LA    R1,100(,R13)       R1 -> param list
         OI    104(R13),X'80'     Mark last param (VL)
         L     R15,=V(ADD_INTS)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    104(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         XC    100(4,R13),100(R13)  Init local var to 0
         LA    R2,100(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LA    R2,5            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,100(,R13)       Load addr of local var
         LA    R15,4(,R2)        Struct field at offset 4
         LA    R2,7            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         L     R15,88(,R13)       Load from stack slot
*        Call setup (reentrant)
         LA    R0,100(,R13)       Load addr of local var
         ST    R0,104(,R13)       Store param 0
         LA    R1,104(,R13)       R1 -> param list
         OI    104(R13),X'80'     Mark last param (VL)
         L     R15,=V(POINT_SUM)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    104(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         XC    104(4,R13),104(R13)  Init local var to 0
         LA    R2,104(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LA    R2,0            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,104(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LA    R15,4(,R2)        Struct field at offset 4
         LA    R2,0            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,104(,R13)       Load addr of local var
         LA    R15,8(,R2)        Struct field at offset 8
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LA    R2,10            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,104(,R13)       Load addr of local var
         LA    R15,8(,R2)        Struct field at offset 8
         LR    R2,R15            Copy result
         LA    R15,4(,R2)        Struct field at offset 4
         LA    R2,5            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         L     R15,88(,R13)       Load from stack slot
*        Call setup (reentrant)
         LA    R0,104(,R13)       Load addr of local var
         ST    R0,108(,R13)       Store param 0
         LA    R1,108(,R13)       R1 -> param list
         OI    108(R13),X'80'     Mark last param (VL)
         L     R15,=V(RECT_AREA)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    108(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         XC    108(4,R13),108(R13)  Init local var to 0
         LA    R2,108(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LA    R2,0            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,108(,R13)       Load addr of local var
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LA    R2,42            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         L     R15,88(,R13)       Load from stack slot
*        Call setup (reentrant)
         LA    R0,108(,R13)       Load addr of local var
         ST    R0,112(,R13)       Store param 0
         LA    R1,112(,R13)       R1 -> param list
         OI    112(R13),X'80'     Mark last param (VL)
         L     R15,=V(GET_VARIANT_INT)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    112(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         XC    112(4,R13),112(R13)  Init local var to 0
         LA    R2,112(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LA    R2,100            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         LA    R2,112(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LA    R15,4(,R2)        Struct field at offset 4
         LA    R2,200            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         L     R15,88(,R13)       Load from stack slot
*        Call setup (reentrant)
         LA    R0,112(,R13)       Load addr of local var
         ST    R0,116(,R13)       Store param 0
         LA    R1,116(,R13)       R1 -> param list
         OI    116(R13),X'80'     Mark last param (VL)
         L     R15,=V(GET_POINT_X)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    116(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         XC    116(4,R13),116(R13)  Init local var to 0
         LA    R2,116(,R13)       Load addr of local var
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LA    R2,7            Load constant
         LR    R3,R15            Copy result
         ST    R2,0(,R3)         Store to address
         L     R15,88(,R13)       Load from stack slot
*        Call setup (reentrant)
         LA    R0,116(,R13)       Load addr of local var
         ST    R0,120(,R13)       Store param 0
         LA    R1,120(,R13)       R1 -> param list
         OI    120(R13),X'80'     Mark last param (VL)
         L     R15,=V(GET_DEEP_VALUE)        Load entry point
         BALR  R14,R15           Call subroutine
         NI    120(R13),X'7F'     Clear VL bit
         L     R2,88(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,88(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R15,88(,R13)       Load value from stack slot
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
NODE_SUM DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING NODE_SUM,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
NODE_SUM$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         XC    92(4,R13),92(R13)  Init local var to 0
         LA    R2,0            Load constant
         ST    R2,92(,R13)        Store to stack slot
         XC    96(4,R13),96(R13)  Init local var to 0
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         ST    R2,96(,R13)        Store to stack slot
         B     NODE_SUM$WHILE.COND            Branch unconditional
NODE_SUM$WHILE.COND DS    0H
         L     R15,96(,R13)       Load from stack slot
         L     R2,96(,R13)       Load value from stack slot
         LA    R3,0            Load constant
         CR    R2,R3             Compare registers
         LA    R15,1             Assume true
         BNE   *+6               Skip if condition met
         SR    R15,R15           Set false
         LR    R2,R15            Copy result
         LTR   R2,R2             Test register
         BNZ   NODE_SUM$WHILE.BODY            Branch if not zero
         B     NODE_SUM$WHILE.END            Branch to else
NODE_SUM$WHILE.BODY DS    0H
         L     R15,92(,R13)       Load from stack slot
         L     R15,96(,R13)       Load from stack slot
         L     R2,96(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         L     R2,92(,R13)       Load value from stack slot
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,92(,R13)        Store to stack slot
         L     R15,96(,R13)       Load from stack slot
         L     R2,96(,R13)       Load value from stack slot
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         LR    R2,R15            Copy result
         ST    R2,96(,R13)        Store to stack slot
         B     NODE_SUM$WHILE.COND            Branch unconditional
NODE_SUM$WHILE.END DS    0H
         L     R15,92(,R13)       Load from stack slot
         L     R15,92(,R13)       Load value from stack slot
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
GET_DEEP_VALUE DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING GET_DEEP_VALUE,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
GET_DEEP_VALUE$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
GET_POINT_X DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING GET_POINT_X,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
GET_POINT_X$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
GET_VARIANT_INT DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING GET_VARIANT_INT,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
GET_VARIANT_INT$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         LR    R2,R15            Copy result
         LA    R3,0            Load constant
         CR    R2,R3             Compare registers
         LA    R15,1             Assume true
         BE    *+6               Skip if condition met
         SR    R15,R15           Set false
         LR    R2,R15            Copy result
         LA    R3,0            Load constant
         CR    R2,R3             Compare registers
         LA    R15,1             Assume true
         BNE   *+6               Skip if condition met
         SR    R15,R15           Set false
         LR    R2,R15            Copy result
         LTR   R2,R2             Test register
         BNZ   GET_VARIANT_INT$IF.THEN            Branch if not zero
         B     GET_VARIANT_INT$IF.END            Branch to else
GET_VARIANT_INT$IF.THEN DS    0H
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         B     GET_VARIANT_INT$IF.END            Branch unconditional
GET_VARIANT_INT$IF.END DS    0H
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
RECT_AREA DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING RECT_AREA,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
RECT_AREA$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         XC    92(4,R13),92(R13)  Init local var to 0
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LA    R15,8(,R2)        Struct field at offset 8
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         LR    R2,R15            Copy result
         LR    R3,R15            Copy result
         SR    R2,R3             Subtract registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,92(,R13)        Store to stack slot
         XC    96(4,R13),96(R13)  Init local var to 0
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LA    R15,8(,R2)        Struct field at offset 8
         LR    R2,R15            Copy result
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         LR    R2,R15            Copy result
         LR    R3,R15            Copy result
         SR    R2,R3             Subtract registers
         LR    R15,R2            Result in R15
         LR    R2,R15            Copy result
         ST    R2,96(,R13)        Store to stack slot
         L     R15,92(,R13)       Load from stack slot
         L     R15,96(,R13)       Load from stack slot
         L     R3,92(,R13)       Load value from stack slot
         L     R4,96(,R13)       Load value from stack slot
         MR    R2,R4             R2:R3 = R3 * R4
         LR    R15,R3            Low 32 bits to R15
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
POINT_SUM DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING POINT_SUM,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
POINT_SUM$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LR    R15,R2             Struct field at offset 0
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         L     R15,88(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         LA    R15,4(,R2)        Struct field at offset 4
         LR    R2,R15            Copy result
         L     R15,0(,R2)        Load from address
         LR    R2,R15            Copy result
         LR    R3,R15            Copy result
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
ADD_INTS DS    0H
         STM   R14,R12,12(R13)    Save caller's registers
         LR    R12,R15            Copy entry point to base reg
         USING ADD_INTS,R12            Establish addressability
         LR    R11,R1             Save parameter list pointer
*        Set up save area chain (stack allocation)
         LA    R2,72(,R13)        R2 -> our save area (after caller's)
         ST    R13,4(,R2)         Chain: new->prev = caller's
         ST    R2,8(,R13)         Chain: caller->next = new
         LR    R13,R2             R13 -> our save area
*
ADD_INTS$ENTRY DS    0H
         XC    88(4,R13),88(R13)  Init local var to 0
         L     R2,0(,R11)       Load addr of param 0
         L     R2,0(,R2)         Load param value
         ST    R2,88(,R13)        Store to stack slot
         XC    92(4,R13),92(R13)  Init local var to 0
         L     R2,4(,R11)       Load addr of param 1
         L     R2,0(,R2)         Load param value
         ST    R2,92(,R13)        Store to stack slot
         L     R15,88(,R13)       Load from stack slot
         L     R15,92(,R13)       Load from stack slot
         L     R2,88(,R13)       Load value from stack slot
         L     R3,92(,R13)       Load value from stack slot
         AR    R2,R3             Add registers
         LR    R15,R2            Result in R15
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
         LA    R15,0            Load constant
*        Function epilogue
         L     R13,4(,R13)        Restore caller's SA pointer
         L     R14,12(,R13)       Restore return address
         LM    R0,R12,20(,R13)    Restore R0-R12
         BR    R14                Return to caller
*
         DROP  R12
*
*
*        Dynamic area sizes (for GETMAIN/FREEMAIN)
DYN@MAIN EQU   128                 Stack frame size for MAIN
DYN@NODE_SUM EQU   104                 Stack frame size for NODE_SUM
DYN@GET_DEEP_VALUE EQU   96                 Stack frame size for GET_DEEP_VALUE
DYN@GET_POINT_X EQU   96                 Stack frame size for GET_POINT_X
DYN@GET_VARIANT_INT EQU   96                 Stack frame size for GET_VARIANT_INT
DYN@RECT_AREA EQU   104                 Stack frame size for RECT_AREA
DYN@POINT_SUM EQU   96                 Stack frame size for POINT_SUM
DYN@ADD_INTS EQU   96                 Stack frame size for ADD_INTS
*
         LTORG                    Literal pool
*
*        Register equates
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
         END   MAIN
