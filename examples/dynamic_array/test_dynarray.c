/*
 * Test program for ANVIL-generated dynamic array library
 * 
 * This C program links with the assembly code generated by generate_dynarray.c
 * to test the dynamic array functions that call C library functions.
 * 
 * Build instructions:
 *   # 1. Generate the assembly code:
 *   ./generate_dynarray arm64_macos > dynarray_lib.s
 * 
 *   # 2. Assemble and link:
 *   as dynarray_lib.s -o dynarray_lib.o
 *   gcc test_dynarray.c dynarray_lib.o -o test_dynarray
 * 
 *   # 3. Run:
 *   ./test_dynarray
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* Declare the external functions from our generated assembly */
extern int* array_create(int capacity);
extern void array_destroy(int* arr);
extern int* array_copy(int* src, int count);
extern int array_sum(int* arr, int count);
extern int array_max(int* arr, int count);
extern int array_min(int* arr, int count);
extern int array_count_if(int* arr, int n, int threshold);
extern void array_scale(int* arr, int n, int factor);

/* Test result tracking */
static int tests_passed = 0;
static int tests_failed = 0;

/* Test macro */
#define TEST(name, condition) \
    do { \
        if (condition) { \
            printf("  [PASS] %s\n", name); \
            tests_passed++; \
        } else { \
            printf("  [FAIL] %s\n", name); \
            tests_failed++; \
        } \
    } while (0)

#define TEST_EQ(name, got, expected) \
    do { \
        if ((got) == (expected)) { \
            printf("  [PASS] %s: got %d, expected %d\n", name, got, expected); \
            tests_passed++; \
        } else { \
            printf("  [FAIL] %s: got %d, expected %d\n", name, got, expected); \
            tests_failed++; \
        } \
    } while (0)

/* Helper to print array */
static void print_array(const char *name, int *arr, int n)
{
    printf("  %s = [", name);
    for (int i = 0; i < n; i++) {
        printf("%d", arr[i]);
        if (i < n - 1) printf(", ");
    }
    printf("]\n");
}

int main(void)
{
    printf("=== ANVIL Dynamic Array Library Test ===\n");
    printf("Testing functions that call malloc, free, memcpy\n\n");
    
    /* ================================================================
     * Test array_create and array_destroy
     * ================================================================ */
    printf("Testing array_create / array_destroy:\n");
    {
        int *arr = array_create(10);
        TEST("array_create returns non-NULL", arr != NULL);
        
        if (arr) {
            /* Initialize the array */
            for (int i = 0; i < 10; i++) {
                arr[i] = i * 10;
            }
            print_array("arr", arr, 10);
            
            TEST_EQ("arr[0]", arr[0], 0);
            TEST_EQ("arr[5]", arr[5], 50);
            TEST_EQ("arr[9]", arr[9], 90);
            
            array_destroy(arr);
            printf("  [INFO] array_destroy completed (no crash = success)\n");
            tests_passed++;
        }
    }
    printf("\n");
    
    /* ================================================================
     * Test array_copy
     * ================================================================ */
    printf("Testing array_copy:\n");
    {
        int src[] = {1, 2, 3, 4, 5};
        int n = 5;
        
        print_array("src", src, n);
        
        int *copy = array_copy(src, n);
        TEST("array_copy returns non-NULL", copy != NULL);
        
        if (copy) {
            print_array("copy", copy, n);
            
            /* Verify copy is identical */
            bool identical = true;
            for (int i = 0; i < n; i++) {
                if (copy[i] != src[i]) {
                    identical = false;
                    break;
                }
            }
            TEST("copy is identical to source", identical);
            
            /* Verify it's a true copy (different memory) */
            copy[0] = 999;
            TEST("modifying copy doesn't affect source", src[0] == 1);
            
            array_destroy(copy);
        }
    }
    printf("\n");
    
    /* ================================================================
     * Test array_sum
     * ================================================================ */
    printf("Testing array_sum:\n");
    {
        int arr1[] = {1, 2, 3, 4, 5};
        print_array("arr1", arr1, 5);
        TEST_EQ("sum of [1,2,3,4,5]", array_sum(arr1, 5), 15);
        
        int arr2[] = {10, 20, 30};
        print_array("arr2", arr2, 3);
        TEST_EQ("sum of [10,20,30]", array_sum(arr2, 3), 60);
        
        int arr3[] = {-5, 5, -10, 10};
        print_array("arr3", arr3, 4);
        TEST_EQ("sum of [-5,5,-10,10]", array_sum(arr3, 4), 0);
        
        int arr4[] = {100};
        TEST_EQ("sum of single element", array_sum(arr4, 1), 100);
    }
    printf("\n");
    
    /* ================================================================
     * Test array_max
     * ================================================================ */
    printf("Testing array_max:\n");
    {
        int arr1[] = {3, 1, 4, 1, 5, 9, 2, 6};
        print_array("arr1", arr1, 8);
        TEST_EQ("max of [3,1,4,1,5,9,2,6]", array_max(arr1, 8), 9);
        
        int arr2[] = {-10, -5, -20, -1};
        print_array("arr2", arr2, 4);
        TEST_EQ("max of negative numbers", array_max(arr2, 4), -1);
        
        int arr3[] = {42};
        TEST_EQ("max of single element", array_max(arr3, 1), 42);
        
        int arr4[] = {5, 5, 5, 5};
        TEST_EQ("max of all same", array_max(arr4, 4), 5);
    }
    printf("\n");
    
    /* ================================================================
     * Test array_min
     * ================================================================ */
    printf("Testing array_min:\n");
    {
        int arr1[] = {3, 1, 4, 1, 5, 9, 2, 6};
        print_array("arr1", arr1, 8);
        TEST_EQ("min of [3,1,4,1,5,9,2,6]", array_min(arr1, 8), 1);
        
        int arr2[] = {-10, -5, -20, -1};
        print_array("arr2", arr2, 4);
        TEST_EQ("min of negative numbers", array_min(arr2, 4), -20);
        
        int arr3[] = {42};
        TEST_EQ("min of single element", array_min(arr3, 1), 42);
        
        int arr4[] = {7, 7, 7, 7};
        TEST_EQ("min of all same", array_min(arr4, 4), 7);
    }
    printf("\n");
    
    /* ================================================================
     * Test array_count_if
     * ================================================================ */
    printf("Testing array_count_if (count elements > threshold):\n");
    {
        int arr[] = {1, 5, 10, 15, 20, 25, 30};
        print_array("arr", arr, 7);
        
        TEST_EQ("count > 0", array_count_if(arr, 7, 0), 7);
        TEST_EQ("count > 10", array_count_if(arr, 7, 10), 4);
        TEST_EQ("count > 20", array_count_if(arr, 7, 20), 2);
        TEST_EQ("count > 30", array_count_if(arr, 7, 30), 0);
        TEST_EQ("count > 100", array_count_if(arr, 7, 100), 0);
    }
    printf("\n");
    
    /* ================================================================
     * Test array_scale
     * ================================================================ */
    printf("Testing array_scale (multiply all by factor):\n");
    {
        int arr1[] = {1, 2, 3, 4, 5};
        printf("  Before: ");
        print_array("arr1", arr1, 5);
        
        array_scale(arr1, 5, 2);
        printf("  After scale by 2: ");
        print_array("arr1", arr1, 5);
        
        TEST_EQ("arr1[0] after *2", arr1[0], 2);
        TEST_EQ("arr1[2] after *2", arr1[2], 6);
        TEST_EQ("arr1[4] after *2", arr1[4], 10);
        
        int arr2[] = {10, 20, 30};
        array_scale(arr2, 3, 0);
        TEST_EQ("scale by 0 gives 0", arr2[0], 0);
        TEST_EQ("scale by 0 gives 0", arr2[1], 0);
        
        int arr3[] = {5, -5, 10};
        array_scale(arr3, 3, -1);
        TEST_EQ("scale by -1 negates", arr3[0], -5);
        TEST_EQ("scale by -1 negates", arr3[1], 5);
        TEST_EQ("scale by -1 negates", arr3[2], -10);
    }
    printf("\n");
    
    /* ================================================================
     * Combined test: create, manipulate, destroy
     * ================================================================ */
    printf("Testing combined workflow:\n");
    {
        /* Create array */
        int *arr = array_create(100);
        TEST("create array of 100", arr != NULL);
        
        if (arr) {
            /* Fill with values */
            for (int i = 0; i < 100; i++) {
                arr[i] = i + 1;  /* 1 to 100 */
            }
            
            /* Test operations */
            TEST_EQ("sum of 1..100", array_sum(arr, 100), 5050);
            TEST_EQ("max of 1..100", array_max(arr, 100), 100);
            TEST_EQ("min of 1..100", array_min(arr, 100), 1);
            TEST_EQ("count > 50", array_count_if(arr, 100, 50), 50);
            
            /* Make a copy */
            int *copy = array_copy(arr, 100);
            TEST("copy array", copy != NULL);
            
            if (copy) {
                /* Scale the copy */
                array_scale(copy, 100, 2);
                TEST_EQ("scaled sum", array_sum(copy, 100), 10100);
                TEST_EQ("original unchanged", array_sum(arr, 100), 5050);
                
                array_destroy(copy);
            }
            
            array_destroy(arr);
        }
    }
    printf("\n");
    
    /* Summary */
    printf("=== Test Summary ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    printf("Total:  %d\n", tests_passed + tests_failed);
    
    if (tests_failed == 0) {
        printf("\nAll tests passed! The ANVIL-generated library works correctly.\n");
        printf("Successfully demonstrated calling malloc, free, and memcpy from ANVIL code.\n");
        return 0;
    } else {
        printf("\nSome tests failed.\n");
        return 1;
    }
}
